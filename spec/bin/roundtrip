#!/usr/bin/env ruby
# Script to dynamically create specs trying to correctly roundtrip all the .puz files that get
# passed in

if ARGV.size < 1
  puts 'Puzzle file(s) required!'
  puts 'Usage: roundtrip (-v) (-mdfind) (-save) </path/to/puzfile.puz>...'
  puts 'Options:'
  puts '  -v       verbose mode'
  puts '  -mdfind  use mdfind on OS X to find .puz files'
  puts '  -save-failed    save failures to spec/tmp'
  puts 'exiting...'
  exit
end

require 'fileutils'
require File.expand_path('../../spec_helper', __FILE__)

SAVE_ROOT = File.expand_path('../../tmp', __FILE__)

def color(text, color_code)
  "\e[#{color_code}m#{text}\e[0m"
end
def red(text); color(text, 31); end
def green(text); color(text, 32); end
def yellow(text); color(text, 33); end

def dot(text, color)
  if $roundtrip_verbose
    puts color(text, color)
  else
    print color('.', color)
  end
end
def rdot(text); dot(text, 31); end
def gdot(text); dot(text, 32); end
def ydot(text); dot(text, 33); end

args = ARGV.dup
$roundtrip_verbose = !!args.delete('-v')
save_fails = 'true'  if args.delete('-save-fails')

if args.delete('-mdfind')
  if RUBY_PLATFORM[/darwin/i]
    args += `mdfind 'kMDItemFSName = "*.puz"'`.split("\n").compact
    # Assume they've been copied by this script
    args.reject! { |f| File.identical?(SAVE_ROOT, File.dirname(f)) }
  else
    $stderr.puts red('mdfind only available on OS X')
  end
end

counts = Hash.new(0)
fails = []


def save_fail(f)
  FileUtils.cp(f, SAVE_ROOT)
rescue ArgumentError
end

args.each do |f|
  if File.exists?(f)
    if RoundTripper::ROUNDTRIP_INVALIDS.include?(f)
      ydot("Skipping known invalid: #{f}")
    else
      if File.size(f) > 0
        matcher = RoundTripper::Matcher.new
        begin
          if matcher.matches?(f)
            gdot("Success: #{f}")
            counts[:success] += 1
          else
            rdot("Fail: #{f}")
            fails << [f, matcher.failure_message]
          end
        rescue StandardError => e
          rdot("Fail: #{f}")
          fails << [f, ([e.message] + e.backtrace.map { |l| "\t" + l }).join("\n")]
        end
      else
        ydot("Skipping empty file: #{f}")
        counts[:skipped] += 1
      end
    end
  else
    $stderr.puts red("File does not exist! Skipping: #{f}")
    counts[:skipped] += 1
  end
end

puts  unless $roundtrip_verbose

unless fails.empty?
  puts
  puts red('FAILS')
  puts red('#####')
  fails.each do |f, message|
    puts
    puts red(f)
    puts red(message)
    puts
    save_fail(f)  if save_fails
  end

end

puts green("Success #{counts[:success]}") + ' | ' + red("Fail #{fails.size}") + ' | ' +
     yellow("Skipped: #{counts[:skipped]}")
